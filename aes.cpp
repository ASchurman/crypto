#include "aes.h"
#include <cassert>
#include <algorithm>
#include <fstream>
#include <filesystem>
#include <string>
#include <cstdlib>
#include <ctime>

const std::array<uint8_t, 256> AES::SBOX =
 {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

const std::array<uint8_t, 256> AES::INV_SBOX =
 {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb 
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb 
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e 
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25 
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92 
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84 
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06 
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b 
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73 
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e 
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b 
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4 
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f 
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef 
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61 
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d};

const std::array<uint8_t, 256> AES::GMUL2 = 
{0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,	
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};

const std::array<uint8_t, 256> AES::GMUL3 = 
{0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,	
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,	
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,	
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,	
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a};

const std::array<uint8_t, 256> AES::GMUL9 = 
{0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,	
0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,	
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,	
0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46};

const std::array<uint8_t, 256> AES::GMUL11 = 
{0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3};

const std::array<uint8_t, 256> AES::GMUL13 = 
{0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97};

const std::array<uint8_t, 256> AES::GMUL14 =
{0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d};

const std::array<uint8_t, 10> AES::RC = 
{0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};

AES::AES(const std::vector<uint8_t>& key)
{
    keyExpansion(key);
}

void AES::cleanup()
{
    for (auto& roundKey : m_roundKeys)
    {
        std::fill(roundKey.begin(), roundKey.end(), 0);
    }
    std::fill(m_state.begin(), m_state.end(), 0);
}

void AES::encrypt(std::istream& plaintext, std::ostream& ciphertext)
{
    // For now, only implement ECB mode.
    // Iterate over the plaintext, encrypting each 16-byte block
    // and writing them to ciphertext.
    bool doneLooping = false;
    do
    {
        plaintext.read(reinterpret_cast<char*>(m_state.data()), 16);
        if (plaintext.eof())
        {
            // We just read the final block of plaintext. Now we need to
            // figure out how to pad the final block.
            uint8_t padBytes = 16 - plaintext.gcount();
            for (int i = plaintext.gcount(); i < 16; i++)
            {
                m_state[i] = padBytes;
            }
            doneLooping = true;
        }

        // Initial round key addition
        addRoundKey(0);

        // For now, only implement AES-128, which means 10 rounds
        int numRounds = 10;
        for (int i = 1; i < numRounds; i++)
        {
            subBytes();
            shiftRows();
            mixColumns();
            addRoundKey(i);
        }
        // Final round: don't do the MixColumns step
        subBytes();
        shiftRows();
        addRoundKey(numRounds);

        ciphertext.write(reinterpret_cast<char*>(m_state.data()), 16);
    }
    while (!doneLooping);
}

void AES::decrypt(std::istream& ciphertext, std::ostream& plaintext, bool usePadding)
{
    // For now, only implement ECB mode.
    // Iterate over the ciphertext, decrypting each 16-byte block
    // and writing them to plaintext.
    for (;;)
    {
        ciphertext.read(reinterpret_cast<char*>(m_state.data()), 16);
        if (ciphertext.eof())
        {
            // We should always have an integer number of blocks when decrypting,
            // because we pad the input to have an integer number of blocks.
            assert(ciphertext.gcount() == 0); // TODO handle this more gracefully
            break;
        }

        // For now, only implement AES-128, which means 10 rounds
        int numRounds = 10;

        // Initial round. Don't do the inverse MixColumns step
        addRoundKey(numRounds);
        invShiftRows();
        invSubBytes();

        // The rest of the rounds...
        for (int i = numRounds-1; i > 0; i--)
        {
            addRoundKey(i);
            invMixColumns();
            invShiftRows();
            invSubBytes();
        }

        // Final round key addition
        addRoundKey(0);

        // Now m_state contains the plain text of this block.
        // Before writing this to plaintext, check to see if this was the last block.
        int numBytesToWrite = 16;
        if (usePadding && ciphertext.peek() == EOF)
        {
            // This was the last block! Verify and strip the padding
            int padding = m_state[15];
            for (int i = 16-padding; i < 15; i++)
            {
                if (m_state[i] != padding)
                {
                    for (int j = 0; j < 16; j++)
                    {
                        std::cout << std::hex << static_cast<int>(m_state[j]);
                        std::cout << "\n";
                    }
                    // Problem! We expected 'padding' number of padding bytes, but found fewer
                    assert(false); // TODO handle this more gracefully
                }
            }
            numBytesToWrite = 16 - padding;
        }
        plaintext.write(reinterpret_cast<char*>(m_state.data()), numBytesToWrite);
    }
}

void AES::keyExpansion(const std::vector<uint8_t>& key)
{
    // For now, only implement AES-128
    assert(key.size() == 16);

    // For now, assume that we're only working with AES-128. This means 11 round keys
    m_roundKeys.resize(11);

    // The first round key is equal to the AES key
    std::copy(key.begin(), key.end(), m_roundKeys[0].begin());

    // Derive the rest of the 11 keys from the first
    for (int k = 1; k < 11; k++)
    {
        // Derive the first column of the k-th round key
        std::array<uint8_t, 4> g;
        // g=last col of prev key
        for (int i = 0; i < 4; i++) g[i] = m_roundKeys[k-1][i+12];
        // 1-byte left circular rotation
        uint8_t g0 = g[0];
        for (int i = 0; i < 3; i++) g[i] = g[i+1];
        g[3] = g0;
        // SubBytes on each byte of g
        for (int i = 0; i < 4; i++) g[i] = SBOX[g[i]];
        // XOR g with the round constant
        g[0] ^= RC[k-1];

        for (int i = 0; i < 4; i++) m_roundKeys[k][i] = m_roundKeys[k-1][i] ^ g[i];

        // For the rest of the bytes, XOR the corresponding byte of the previous key
        // with the corresponding byte of the previous column of this key
        for (int i = 4; i < 16; i++) m_roundKeys[k][i] = m_roundKeys[k-1][i] ^ m_roundKeys[k][i-4];
    }
}

void AES::addRoundKey(int round)
{
    for (int i = 0; i < 16; i++) m_state[i] ^= m_roundKeys[round][i];
}

void AES::subBytes()
{
    for (int i = 0; i < 16; i++)
    {
        m_state[i] = SBOX[m_state[i]];
    }
}

void AES::invSubBytes()
{
    for (int i = 0; i < 16; i++)
    {
        m_state[i] = INV_SBOX[m_state[i]];
    }
}

void AES::shiftRows()
{
    std::array<uint8_t, 16> oldState = m_state;
    
    // Row 1 (indices 0, 4, 8, 12) doesn't shift

    // Row 2 (indices 1, 5, 9, 13) shifts 1
    m_state[1] = oldState[5];
    m_state[5] = oldState[9];
    m_state[9] = oldState[13];
    m_state[13] = oldState[1];

    // Row 3 (indices 2, 6, 10, 14) shifts 2
    m_state[2] = oldState[10];
    m_state[6] = oldState[14];
    m_state[10] = oldState[2];
    m_state[14] = oldState[6];

    // Row 4 (indices 3, 7, 11, 15) shifts 3
    m_state[3] = oldState[15];
    m_state[7] = oldState[3];
    m_state[11] = oldState[7];
    m_state[15] = oldState[11];
}

void AES::invShiftRows()
{
    std::array<uint8_t, 16> oldState = m_state;
    
    // Row 1 (indices 0, 4, 8, 12) doesn't shift

    // Row 2 (indices 1, 5, 9, 13) shifts 1
    m_state[1] = oldState[13];
    m_state[5] = oldState[1];
    m_state[9] = oldState[5];
    m_state[13] = oldState[9];

    // Row 3 (indices 2, 6, 10, 14) shifts 2
    m_state[2] = oldState[10];
    m_state[6] = oldState[14];
    m_state[10] = oldState[2];
    m_state[14] = oldState[6];

    // Row 4 (indices 3, 7, 11, 15) shifts 3
    m_state[3] = oldState[7];
    m_state[7] = oldState[11];
    m_state[11] = oldState[15];
    m_state[15] = oldState[3];
}

void AES::mixColumns()
{
    std::array<uint8_t, 16> oldState = m_state;
    for (int i = 0; i < 16; i += 4)
    {
        m_state[i]  = GMUL2[oldState[i]] ^ GMUL3[oldState[i+1]] ^ oldState[i+2]        ^ oldState[i+3];
        m_state[i+1]= oldState[i]        ^ GMUL2[oldState[i+1]] ^ GMUL3[oldState[i+2]] ^ oldState[i+3];
        m_state[i+2]= oldState[i]        ^ oldState[i+1]        ^ GMUL2[oldState[i+2]] ^ GMUL3[oldState[i+3]];
        m_state[i+3]= GMUL3[oldState[i]] ^ oldState[i+1]        ^ oldState[i+2]        ^ GMUL2[oldState[i+3]];
    }
}

void AES::invMixColumns()
{
    std::array<uint8_t, 16> oldState = m_state;
    for (int i = 0; i < 16; i += 4)
    {
        m_state[i]  = GMUL14[oldState[i]] ^ GMUL11[oldState[i+1]] ^ GMUL13[oldState[i+2]] ^ GMUL9[oldState[i+3]];
        m_state[i+1]= GMUL9[oldState[i]]  ^ GMUL14[oldState[i+1]] ^ GMUL11[oldState[i+2]] ^ GMUL13[oldState[i+3]];
        m_state[i+2]= GMUL13[oldState[i]] ^ GMUL9[oldState[i+1]]  ^ GMUL14[oldState[i+2]] ^ GMUL11[oldState[i+3]];
        m_state[i+3]= GMUL11[oldState[i]] ^ GMUL13[oldState[i+1]] ^ GMUL9[oldState[i+2]]  ^ GMUL14[oldState[i+3]];
    }
}

/************************************************************************************************
 ************************************************************************************************
 ******************************** BEGIN TESTS ***************************************************
 * **********************************************************************************************
 ***********************************************************************************************/

void AES::test()
{
    cleanup();
    testSteps();
    cleanup();
    testEncryptDecrypt();
    cleanup();
    testEndToEnd(".\\testFiles\\texttest.txt");
    cleanup();
    testEndToEnd(".\\testFiles\\largetest.txt");
    cleanup();
    testEndToEnd(".\\testFiles\\TheCallingOfSaintMatthew.jpg");
    cleanup();
}

void AES::testSteps()
{
    const std::vector<uint8_t> key1 =
    {0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00};
    const uint8_t roundkeys1[11][16] =
    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
     {0x62,0x63,0x63,0x63,0x62,0x63,0x63,0x63,0x62,0x63,0x63,0x63,0x62,0x63,0x63,0x63}, 
     {0x9b,0x98,0x98,0xc9,0xf9,0xfb,0xfb,0xaa,0x9b,0x98,0x98,0xc9,0xf9,0xfb,0xfb,0xaa}, 
     {0x90,0x97,0x34,0x50,0x69,0x6c,0xcf,0xfa,0xf2,0xf4,0x57,0x33,0x0b,0x0f,0xac,0x99}, 
     {0xee,0x06,0xda,0x7b,0x87,0x6a,0x15,0x81,0x75,0x9e,0x42,0xb2,0x7e,0x91,0xee,0x2b}, 
     {0x7f,0x2e,0x2b,0x88,0xf8,0x44,0x3e,0x09,0x8d,0xda,0x7c,0xbb,0xf3,0x4b,0x92,0x90}, 
     {0xec,0x61,0x4b,0x85,0x14,0x25,0x75,0x8c,0x99,0xff,0x09,0x37,0x6a,0xb4,0x9b,0xa7}, 
     {0x21,0x75,0x17,0x87,0x35,0x50,0x62,0x0b,0xac,0xaf,0x6b,0x3c,0xc6,0x1b,0xf0,0x9b}, 
     {0x0e,0xf9,0x03,0x33,0x3b,0xa9,0x61,0x38,0x97,0x06,0x0a,0x04,0x51,0x1d,0xfa,0x9f}, 
     {0xb1,0xd4,0xd8,0xe2,0x8a,0x7d,0xb9,0xda,0x1d,0x7b,0xb3,0xde,0x4c,0x66,0x49,0x41}, 
     {0xb4,0xef,0x5b,0xcb,0x3e,0x92,0xe2,0x11,0x23,0xe9,0x51,0xcf,0x6f,0x8f,0x18,0x8e}};
    const std::vector<uint8_t> key2 =
    {0xff,0xff,0xff,0xff,
     0xff,0xff,0xff,0xff,
     0xff,0xff,0xff,0xff,
     0xff,0xff,0xff,0xff};
    const uint8_t roundkeys2[11][16] =
    {{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff},
     {0xe8,0xe9,0xe9,0xe9,0x17,0x16,0x16,0x16,0xe8,0xe9,0xe9,0xe9,0x17,0x16,0x16,0x16}, 
     {0xad,0xae,0xae,0x19,0xba,0xb8,0xb8,0x0f,0x52,0x51,0x51,0xe6,0x45,0x47,0x47,0xf0}, 
     {0x09,0x0e,0x22,0x77,0xb3,0xb6,0x9a,0x78,0xe1,0xe7,0xcb,0x9e,0xa4,0xa0,0x8c,0x6e}, 
     {0xe1,0x6a,0xbd,0x3e,0x52,0xdc,0x27,0x46,0xb3,0x3b,0xec,0xd8,0x17,0x9b,0x60,0xb6}, 
     {0xe5,0xba,0xf3,0xce,0xb7,0x66,0xd4,0x88,0x04,0x5d,0x38,0x50,0x13,0xc6,0x58,0xe6}, 
     {0x71,0xd0,0x7d,0xb3,0xc6,0xb6,0xa9,0x3b,0xc2,0xeb,0x91,0x6b,0xd1,0x2d,0xc9,0x8d}, 
     {0xe9,0x0d,0x20,0x8d,0x2f,0xbb,0x89,0xb6,0xed,0x50,0x18,0xdd,0x3c,0x7d,0xd1,0x50}, 
     {0x96,0x33,0x73,0x66,0xb9,0x88,0xfa,0xd0,0x54,0xd8,0xe2,0x0d,0x68,0xa5,0x33,0x5d}, 
     {0x8b,0xf0,0x3f,0x23,0x32,0x78,0xc5,0xf3,0x66,0xa0,0x27,0xfe,0x0e,0x05,0x14,0xa3}, 
     {0xd6,0x0a,0x35,0x88,0xe4,0x72,0xf0,0x7b,0x82,0xd2,0xd7,0x85,0x8c,0xd7,0xc3,0x26}};
    const std::vector<uint8_t> key3 =
    {0x00,0x01,0x02,0x03,
     0x04,0x05,0x06,0x07,
     0x08,0x09,0x0a,0x0b,
     0x0c,0x0d,0x0e,0x0f};
    const uint8_t roundkeys3[11][16] =
    {{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},
     {0xd6,0xaa,0x74,0xfd,0xd2,0xaf,0x72,0xfa,0xda,0xa6,0x78,0xf1,0xd6,0xab,0x76,0xfe}, 
     {0xb6,0x92,0xcf,0x0b,0x64,0x3d,0xbd,0xf1,0xbe,0x9b,0xc5,0x00,0x68,0x30,0xb3,0xfe}, 
     {0xb6,0xff,0x74,0x4e,0xd2,0xc2,0xc9,0xbf,0x6c,0x59,0x0c,0xbf,0x04,0x69,0xbf,0x41}, 
     {0x47,0xf7,0xf7,0xbc,0x95,0x35,0x3e,0x03,0xf9,0x6c,0x32,0xbc,0xfd,0x05,0x8d,0xfd}, 
     {0x3c,0xaa,0xa3,0xe8,0xa9,0x9f,0x9d,0xeb,0x50,0xf3,0xaf,0x57,0xad,0xf6,0x22,0xaa}, 
     {0x5e,0x39,0x0f,0x7d,0xf7,0xa6,0x92,0x96,0xa7,0x55,0x3d,0xc1,0x0a,0xa3,0x1f,0x6b}, 
     {0x14,0xf9,0x70,0x1a,0xe3,0x5f,0xe2,0x8c,0x44,0x0a,0xdf,0x4d,0x4e,0xa9,0xc0,0x26}, 
     {0x47,0x43,0x87,0x35,0xa4,0x1c,0x65,0xb9,0xe0,0x16,0xba,0xf4,0xae,0xbf,0x7a,0xd2}, 
     {0x54,0x99,0x32,0xd1,0xf0,0x85,0x57,0x68,0x10,0x93,0xed,0x9c,0xbe,0x2c,0x97,0x4e}, 
     {0x13,0x11,0x1d,0x7f,0xe3,0x94,0x4a,0x17,0xf3,0x07,0xa7,0x8b,0x4d,0x2b,0x30,0xc5}};
    const std::vector<uint8_t> key4 =
    {0x49,0x20,0xe2,0x99,
     0xa5,0x20,0x52,0x61,
      0x64,0x69,0x6f,0x47,
      0x61,0x74,0x75,0x6e};
    const uint8_t roundkeys4[11][16] =
    {{0x49,0x20,0xe2,0x99,0xa5,0x20,0x52,0x61,0x64,0x69,0x6f,0x47,0x61,0x74,0x75,0x6e},
     {0xda,0xbd,0x7d,0x76,0x7f,0x9d,0x2f,0x17,0x1b,0xf4,0x40,0x50,0x7a,0x80,0x35,0x3e}, 
     {0x15,0x2b,0xcf,0xac,0x6a,0xb6,0xe0,0xbb,0x71,0x42,0xa0,0xeb,0x0b,0xc2,0x95,0xd5}, 
     {0x34,0x01,0xcc,0x87,0x5e,0xb7,0x2c,0x3c,0x2f,0xf5,0x8c,0xd7,0x24,0x37,0x19,0x02}, 
     {0xa6,0xd5,0xbb,0xb1,0xf8,0x62,0x97,0x8d,0xd7,0x97,0x1b,0x5a,0xf3,0xa0,0x02,0x58}, 
     {0x56,0xa2,0xd1,0xbc,0xae,0xc0,0x46,0x31,0x79,0x57,0x5d,0x6b,0x8a,0xf7,0x5f,0x33}, 
     {0x1e,0x6d,0x12,0xc2,0xb0,0xad,0x54,0xf3,0xc9,0xfa,0x09,0x98,0x43,0x0d,0x56,0xab}, 
     {0x89,0xdc,0x70,0xd8,0x39,0x71,0x24,0x2b,0xf0,0x8b,0x2d,0xb3,0xb3,0x86,0x7b,0x18}, 
     {0x4d,0xfd,0xdd,0xb5,0x74,0x8c,0xf9,0x9e,0x84,0x07,0xd4,0x2d,0x37,0x81,0xaf,0x35}, 
     {0x5a,0x84,0x4b,0x2f,0x2e,0x08,0xb2,0xb1,0xaa,0x0f,0x66,0x9c,0x9d,0x8e,0xc9,0xa9}, 
     {0x75,0x59,0x98,0x71,0x5b,0x51,0x2a,0xc0,0xf1,0x5e,0x4c,0x5c,0x6c,0xd0,0x85,0xf5}};

    const uint8_t state1[16] =
    {0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00};
    const uint8_t state2[16] =
    {0x49, 0x20, 0xe2, 0x99,
     0xa5, 0x20, 0x52, 0x61,
     0x64, 0x69, 0x6f, 0x47,
     0x61, 0x74, 0x75, 0x6e};
    const uint8_t state3[16] =
    {0x3c, 0x5a, 0x4e, 0xd7,
     0x5b, 0x03, 0x41, 0x8c,
     0x65, 0x2b, 0xfc, 0x8f,
     0x18, 0x10, 0x75, 0xea};
    const uint8_t state4[16] =
    {0xdb, 0x13, 0x53, 0x45,
     0xf2, 0x0a, 0x22, 0x5c,
     0x01, 0x01, 0x01, 0x01,
     0x2d, 0x26, 0x31, 0x4c};

    const uint8_t subbedState1[16] =
    {0x63, 0x63, 0x63, 0x63,
     0x63, 0x63, 0x63, 0x63,
     0x63, 0x63, 0x63, 0x63,
     0x63, 0x63, 0x63, 0x63};
    const uint8_t subbedState2[16] =
    {0x3b, 0xb7, 0x98, 0xee,
     0x06, 0xb7, 0x00, 0xef,
     0x43, 0xf9, 0xa8, 0xa0,
     0xef, 0x92, 0x9d, 0x9f};

    const uint8_t shiftState1[16] =
    {0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00};
    const uint8_t shiftState2[16] =
    {0x49, 0x20, 0x6f, 0x6e,
     0xa5, 0x69, 0x75, 0x99,
     0x64, 0x74, 0xe2, 0x61,
     0x61, 0x20, 0x52, 0x47};
    const uint8_t shiftState3[16] =
    {0x3c, 0x03, 0xfc, 0xea,
     0x5b, 0x2b, 0x75, 0xd7,
     0x65, 0x10, 0x4e, 0x8c,
     0x18, 0x5a, 0x41, 0x8f};
    
    const uint8_t mixColState4[16] =
    {0x8e, 0x4d, 0xa1, 0xbc,
     0x9f, 0xdc, 0x58, 0x9d,	
     0x01, 0x01, 0x01, 0x01,
     0x4d, 0x7e, 0xbd, 0xf8};

    /////////////// TEST KEY EXPANSION ///////////////
    keyExpansion(key1);
    for (int i = 0; i < 11; i++)
    {
        for (int j = 0; j < 16; j++)
        {
            assert(m_roundKeys[i][j] == roundkeys1[i][j]);
        }
    }
    keyExpansion(key2);
    for (int i = 0; i < 11; i++)
    {
        for (int j = 0; j < 16; j++)
        {
            assert(m_roundKeys[i][j] == roundkeys2[i][j]);
        }
    }
    keyExpansion(key3);
    for (int i = 0; i < 11; i++)
    {
        for (int j = 0; j < 16; j++)
        {
            assert(m_roundKeys[i][j] == roundkeys3[i][j]);
        }
    }
    keyExpansion(key4);
    for (int i = 0; i < 11; i++)
    {
        for (int j = 0; j < 16; j++)
        {
            assert(m_roundKeys[i][j] == roundkeys4[i][j]);
        }
    }

    /////////////// TEST ADDROUNDKEY ///////////////
    
    for (int i = 0; i < 16; i++) m_state[i] = state1[i];
    addRoundKey(0);
    assert(m_state[0] == 0x49);
    assert(m_state[1] == 0x20);
    assert(m_state[2] == 0xe2);
    assert(m_state[3] == 0x99);
    assert(m_state[4] == 0xa5);
    assert(m_state[5] == 0x20);
    assert(m_state[6] == 0x52);
    assert(m_state[7] == 0x61);
    assert(m_state[8] == 0x64);
    assert(m_state[9] == 0x69);
    assert(m_state[10] == 0x6f);
    assert(m_state[11] == 0x47);
    assert(m_state[12] == 0x61);
    assert(m_state[13] == 0x74);
    assert(m_state[14] == 0x75);
    assert(m_state[15] == 0x6e);
    addRoundKey(1);
    assert(m_state[0] == (0x49 ^ 0xda));
    assert(m_state[1] == (0x20 ^ 0xbd));
    assert(m_state[2] == (0xe2 ^ 0x7d));
    assert(m_state[3] == (0x99 ^ 0x76));
    assert(m_state[4] == (0xa5 ^ 0x7f));
    assert(m_state[5] == (0x20 ^ 0x9d));
    assert(m_state[6] == (0x52 ^ 0x2f));
    assert(m_state[7] == (0x61 ^ 0x17));
    assert(m_state[8] == (0x64 ^ 0x1b));
    assert(m_state[9] == (0x69 ^ 0xf4));
    assert(m_state[10] == (0x6f ^ 0x40));
    assert(m_state[11] == (0x47 ^ 0x50));
    assert(m_state[12] == (0x61 ^ 0x7a));
    assert(m_state[13] == (0x74 ^ 0x80));
    assert(m_state[14] == (0x75 ^ 0x35));
    assert(m_state[15] == (0x6e ^ 0x3e));

    /////////////// TEST SUBBYTES ///////////////

    for (int i = 0; i < 16; i++) m_state[i] = state1[i];
    subBytes();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == subbedState1[i]);
    }
    invSubBytes();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == state1[i]);
    }

    for (int i = 0; i < 16; i++) m_state[i] = state2[i];
    subBytes();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == subbedState2[i]);
    }
    invSubBytes();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == state2[i]);
    }

    /////////////// TEST SHIFTROWS ///////////////

    for (int i = 0; i < 16; i++) m_state[i] = state1[i];
    shiftRows();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == shiftState1[i]);
    }
    invShiftRows();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == state1[i]);
    }

    for (int i = 0; i < 16; i++) m_state[i] = state2[i];
    shiftRows();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == shiftState2[i]);
    }
    invShiftRows();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == state2[i]);
    }

    for (int i = 0; i < 16; i++) m_state[i] = state3[i];
    shiftRows();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == shiftState3[i]);
    }
    invShiftRows();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == state3[i]);
    }

    /////////////// TEST MIXCOLUMNS ///////////////

    for (int i = 0; i < 16; i++) m_state[i] = state4[i];
    mixColumns();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == mixColState4[i]);
    }
    invMixColumns();
    for (int i = 0; i < 16; i++)
    {
        assert(m_state[i] == state4[i]);
    }
}

void AES::testEncryptDecrypt()
{
    // Setup output file, which will hold the output of encrypt or decrypt
    std::string outputFilename = "testOutput.tmp";
    std::fstream outputFile;
    std::array<char, 16> output;
    outputFile.open(outputFilename, std::ios::out);
    assert(outputFile);
    outputFile.close();
    outputFile.open(outputFilename, std::ios::in | std::ios::out | std::ios::binary);
    assert(outputFile);

    // Iterate over the 284 tests
    for (int t = 1; t <= 284; t++)
    {
        std::string keyFilename = ".\\testFiles\\key" + std::to_string(t) + ".test";
        std::ifstream keyFile;
        std::vector<uint8_t> key;
        key.resize(16);

        std::string plaintextFilename = ".\\testFiles\\plaintext" + std::to_string(t) + ".test";
        std::ifstream plaintextFile;
        std::array<char, 16> plaintext;

        std::string ciphertextFilename = ".\\testFiles\\ciphertext" + std::to_string(t) + ".test";
        std::ifstream ciphertextFile;
        std::array<char, 16> ciphertext;

        // Get key
        keyFile.open(keyFilename, std::ios::in | std::ios::binary);
        assert(keyFile);
        keyFile.read(reinterpret_cast<char*>(key.data()), 16);
        keyFile.clear(); keyFile.seekg(0);

        // Get plaintext
        plaintextFile.open(plaintextFilename, std::ios::in | std::ios::binary);
        assert(plaintextFile);
        plaintextFile.read(plaintext.data(), 16);
        plaintextFile.clear(); plaintextFile.seekg(0);

        // Get ciphertext
        ciphertextFile.open(ciphertextFilename, std::ios::in | std::ios::binary);
        assert(ciphertextFile);
        ciphertextFile.read(ciphertext.data(), 16);
        ciphertextFile.clear(); ciphertextFile.seekg(0);

        // Encrypt
        keyExpansion(key);
        encrypt(plaintextFile, outputFile);
        plaintextFile.clear(); plaintextFile.seekg(0);
        outputFile.clear(); outputFile.seekg(0);

        // Verify that output == ciphertext that we expected
        outputFile.read(output.data(), 16);
        for (int i = 0; i < 16; i++)
        {
            assert(output[i] == ciphertext[i]);
        }
        outputFile.clear(); outputFile.seekg(0);

        // Decrypt
        // Don't use padding for decryption, since the NIST test vectors are 16 bytes
        decrypt(ciphertextFile, outputFile, false);
        ciphertextFile.clear(); ciphertextFile.seekg(0);
        outputFile.clear(); outputFile.seekg(0);

        // Verify that output == plaintext that we expected
        outputFile.read(output.data(), 16);
        for (int i = 0; i < 16; i++)
        {
            assert(output[i] == plaintext[i]);
        }
        outputFile.clear(); outputFile.seekg(0);

        // This test is complete, so close the test files
        keyFile.close();
        plaintextFile.close();
        ciphertextFile.close();
    }
    // All of the tests are complete, so close and delete the output file
    outputFile.close();
    std::filesystem::remove(outputFilename);
}

void AES::testEndToEnd(const std::string& plaintextFilename)
{
    std::ifstream plaintextFile;
    plaintextFile.open(plaintextFilename, std::ios::in | std::ios::binary);
    assert(plaintextFile);

    std::string ciphertextFilename = "ciphertext.tmp";
    std::fstream ciphertextFile;
    ciphertextFile.open(ciphertextFilename, std::ios::out);
    ciphertextFile.close();
    ciphertextFile.open(ciphertextFilename, std::ios::in | std::ios::out | std::ios::binary);
    assert(ciphertextFile);

    std::string finalPlaintextFilename = "plaintext.tmp";
    std::fstream finalPlaintextFile;
    finalPlaintextFile.open(finalPlaintextFilename, std::ios::out);
    finalPlaintextFile.close();
    finalPlaintextFile.open(finalPlaintextFilename, std::ios::in | std::ios::out | std::ios::binary);
    assert(finalPlaintextFile);

    std::vector<uint8_t> key;
    key.resize(16);
    srand(time(NULL));
    for (int i = 0; i < 16; i++)
    {
        key[i] = rand() % 256;
    }
    keyExpansion(key);

    encrypt(plaintextFile, ciphertextFile);
    plaintextFile.clear(); plaintextFile.seekg(0);
    ciphertextFile.clear(); ciphertextFile.seekg(0);

    decrypt(ciphertextFile, finalPlaintextFile);
    ciphertextFile.clear(); ciphertextFile.seekg(0);
    finalPlaintextFile.clear(); finalPlaintextFile.seekg(0);

    // Compare plaintextFile and finalPlaintextFile
    for (;;)
    {
        char expected = plaintextFile.get();
        char actual = finalPlaintextFile.get();
        assert(expected == actual);

        if (plaintextFile.eof() || finalPlaintextFile.eof())
        {
            break;
        }
    }

    plaintextFile.close();
    ciphertextFile.close();
    finalPlaintextFile.close();
    std::filesystem::remove(ciphertextFilename);
    std::filesystem::remove(finalPlaintextFilename);
}
