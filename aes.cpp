#include "aes.h"
#include <cassert>
#include <algorithm>
#include <fstream>
#include <stdexcept>
#include <random>

const std::array<uint8_t, 256> AES::SBOX =
 {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

const std::array<uint8_t, 256> AES::INV_SBOX =
 {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb 
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb 
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e 
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25 
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92 
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84 
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06 
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b 
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73 
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e 
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b 
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4 
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f 
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef 
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61 
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d};

const std::array<uint8_t, 256> AES::GMUL2 = 
{0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,	
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};

const std::array<uint8_t, 256> AES::GMUL3 = 
{0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,	
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,	
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,	
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,	
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a};

const std::array<uint8_t, 256> AES::GMUL9 = 
{0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,	
0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,	
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,	
0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46};

const std::array<uint8_t, 256> AES::GMUL11 = 
{0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3};

const std::array<uint8_t, 256> AES::GMUL13 = 
{0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97};

const std::array<uint8_t, 256> AES::GMUL14 =
{0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d};

const std::array<uint8_t, 10> AES::RC = 
{0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};

AES::AES(const std::vector<uint8_t>& key)
{
    if (!keyExpansion(key))
    {
        throw std::invalid_argument("Error: The key is invalid. Key must be 128, 192, or 256 bits.");
    }
}

void AES::cleanup()
{
    for (auto& roundKey : m_roundKeys)
    {
        std::fill(roundKey.begin(), roundKey.end(), 0);
    }
    std::fill(m_state.begin(), m_state.end(), 0);
}

void AES::encrypt(std::istream& plaintext, std::ostream& ciphertext, Mode mode)
{
    // Write header
    ciphertext.put(static_cast<char>(mode));

    // If we're in CBC mode, we'll need an IV, and we'll need to write it to the header
    std::array<uint8_t, 16> cbcVector;
    if (mode == Mode::CBC)
    {
        std::random_device rd;
        std::uniform_int_distribution<int> dist(0, 255);
        for (int i = 0; i < 16; i++) cbcVector[i] = static_cast<uint8_t>(dist(rd));
        ciphertext.write(reinterpret_cast<char*>(cbcVector.data()), 16);
    }

    // Iterate over the plaintext, encrypting each 16-byte block
    // and writing them to ciphertext.
    bool doneLooping = false;
    do
    {
        plaintext.read(reinterpret_cast<char*>(m_state.data()), 16);
        if (plaintext.eof())
        {
            // We just read the final block of plaintext. Now we need to
            // figure out how to pad the final block.
            uint8_t padBytes = 16 - plaintext.gcount();
            for (int i = plaintext.gcount(); i < 16; i++)
            {
                m_state[i] = padBytes;
            }
            doneLooping = true;
        }

        // Add the previous block of ciphertext (or, for the first round, the IV,
        // if we're doing CBC mode.
        if (mode == Mode::CBC)
        {
            for (int i = 0; i < 16; i++) m_state[i] ^= cbcVector[i];
        }

        // Initial round key addition
        addRoundKey(0);

        // Iterate over the rounds...
        int numRounds = m_roundKeys.size() - 1;
        for (int i = 1; i < numRounds; i++)
        {
            subBytes();
            shiftRows();
            mixColumns();
            addRoundKey(i);
        }
        // Final round: don't do the MixColumns step
        subBytes();
        shiftRows();
        addRoundKey(numRounds);

        ciphertext.write(reinterpret_cast<char*>(m_state.data()), 16);

        // If we're doing CBC mode, keep this ciphertext block for the next block
        if (mode == Mode::CBC)
        {
            for (int i = 0; i < 16; i++) cbcVector[i] = m_state[i];
        }
    }
    while (!doneLooping);
}

void AES::decrypt(std::istream& ciphertext, std::ostream& plaintext, bool useHeader, bool usePadding)
{
    // Get the header
    std::array<uint8_t, 16> cbcVector;
    Mode mode = Mode::ECB;
    if (useHeader)
    {
        int modeVal = ciphertext.get();
        switch (modeVal)
        {
            case static_cast<int>(Mode::ECB):
                mode = Mode::ECB;
                break;
            case static_cast<int>(Mode::CBC):
                mode = Mode::CBC;
                ciphertext.read(reinterpret_cast<char*>(cbcVector.data()), 16);
                break;
            default:
                throw std::invalid_argument("Error: Decryption failed. Unrecognized header of ciphertext.");

        }
    }

    // Iterate over the ciphertext, decrypting each 16-byte block
    // and writing them to plaintext.
    for (;;)
    {
        ciphertext.read(reinterpret_cast<char*>(m_state.data()), 16);
        std::array<uint8_t, 16> currCiphertext = m_state;
        if (ciphertext.eof())
        {
            // We should always have an integer number of blocks when decrypting,
            // because we pad the input to have an integer number of blocks.
            if (ciphertext.gcount() != 0)
            {
                // The ciphertext was malformed!
                // This could be a problem with the ciphertext. Or it could be a bad key.
                throw std::invalid_argument("Error: Decryption failed.");
            }
            break;
        }

        int numRounds = m_roundKeys.size() - 1;

        // Initial round. Don't do the inverse MixColumns step
        addRoundKey(numRounds);
        invShiftRows();
        invSubBytes();

        // The rest of the rounds...
        for (int i = numRounds-1; i > 0; i--)
        {
            addRoundKey(i);
            invMixColumns();
            invShiftRows();
            invSubBytes();
        }

        // Final round key addition
        addRoundKey(0);

        if (mode == Mode::CBC)
        {
            for (int i = 0; i < 16; i++)
            {
                m_state[i] ^= cbcVector[i];
                cbcVector[i] = currCiphertext[i];
            }
        }

        // Now m_state contains the plain text of this block.
        // Before writing this to plaintext, check to see if this was the last block.
        int numBytesToWrite = 16;
        if (usePadding && ciphertext.peek() == EOF)
        {
            // This was the last block! Verify and strip the padding
            int padding = m_state[15];
            for (int i = 16-padding; i < 15; i++)
            {
                if (m_state[i] != padding)
                {
                    // Problem! We expected 'padding' number of padding bytes, but found fewer.
                    // The ciphertext was malformed!
                    // This could be a problem with the ciphertext. Or it could be a bad key.
                    throw std::invalid_argument("Error: Decryption failed.");
                }
            }
            numBytesToWrite = 16 - padding;
        }
        plaintext.write(reinterpret_cast<char*>(m_state.data()), numBytesToWrite);
    }
}

bool AES::keyExpansion(const std::vector<uint8_t>& key)
{
    // Holds all of the bytes of the round keys in a single vector.
    // Helpful, because the size of the key and the size of the round keys
    // are different for AES-192 and AES-256. This vector will be divided
    // into sets of 16 bytes as it's put into m_roundKeys.
    std::vector<uint8_t> roundKeysInt;

    switch (key.size())
    {
        case 16:
            m_roundKeys.resize(11);
            roundKeysInt.resize(176);
            break;
        case 24:
            m_roundKeys.resize(13);
            roundKeysInt.resize(216); // 216 instead of 208 in order not to run over the end
            break;
        case 32:
            m_roundKeys.resize(15);
            roundKeysInt.resize(256);
            break;
        default:
            // AES key must be 128, 192, or 256 bits
            return false;
    }

    // The first bytes of the round key are equal to the AES key
    std::copy(key.begin(), key.end(), roundKeysInt.begin());

    // Derive the rest of the bytes from the first key.size() bytes
    int rcon = 0;
    for (int i = key.size(); i < roundKeysInt.size(); i += key.size())
    {
        // Derive first 4 bytes of next set of key.size() bytes
        std::array<uint8_t, 4> g;
        // g = four previous bytes
        g[0] = roundKeysInt[i-4];
        g[1] = roundKeysInt[i-3];
        g[2] = roundKeysInt[i-2];
        g[3] = roundKeysInt[i-1];
        // 1-byte left circular rotation
        uint8_t g0 = g[0];
        for (int j = 0; j < 3; j++) g[j] = g[j+1];
        g[3] = g0;
        // SubBytes on each byte of g
        for (int j = 0; j < 4; j++) g[j] = SBOX[g[j]];
        // XOR g with the round constant
        g[0] ^= RC[rcon];
        rcon++;
        // Use g to get first 4 bytes
        for (int j = 0; j < 4; j++) roundKeysInt[i+j] = roundKeysInt[i+j-key.size()] ^ g[j];

        // For the rest of the bytes, XOR the corresponding byte of the previous chunk
        // with the corresponding byte of the previous column of this chunk
        for (int j = 4; j < key.size(); j++)
        {
            if (key.size() == 32 && j >= 16 && j <= 19)
            {
                roundKeysInt[i+j] = roundKeysInt[i+j-key.size()] ^ SBOX[roundKeysInt[i+j-4]];
            }
            else
            {
                roundKeysInt[i+j] = roundKeysInt[i+j-key.size()] ^ roundKeysInt[i+j-4];
            }
        }
    }
    if (roundKeysInt.size() == 216) roundKeysInt.resize(208);
    if (roundKeysInt.size() == 256) roundKeysInt.resize(240);

    // Now pack roundKeysInt into m_roundKeys
    int j = 0;
    for (int k = 0; k < m_roundKeys.size(); k++)
    {
        for (int i = 0; i < 16; i++)
        {
            m_roundKeys[k][i] = roundKeysInt[j];
            j++;
        }
    }
    return true;
}

void AES::addRoundKey(int round)
{
    for (int i = 0; i < 16; i++) m_state[i] ^= m_roundKeys[round][i];
}

void AES::subBytes()
{
    for (int i = 0; i < 16; i++)
    {
        m_state[i] = SBOX[m_state[i]];
    }
}

void AES::invSubBytes()
{
    for (int i = 0; i < 16; i++)
    {
        m_state[i] = INV_SBOX[m_state[i]];
    }
}

void AES::shiftRows()
{
    std::array<uint8_t, 16> oldState = m_state;
    
    // Row 1 (indices 0, 4, 8, 12) doesn't shift

    // Row 2 (indices 1, 5, 9, 13) shifts 1
    m_state[1] = oldState[5];
    m_state[5] = oldState[9];
    m_state[9] = oldState[13];
    m_state[13] = oldState[1];

    // Row 3 (indices 2, 6, 10, 14) shifts 2
    m_state[2] = oldState[10];
    m_state[6] = oldState[14];
    m_state[10] = oldState[2];
    m_state[14] = oldState[6];

    // Row 4 (indices 3, 7, 11, 15) shifts 3
    m_state[3] = oldState[15];
    m_state[7] = oldState[3];
    m_state[11] = oldState[7];
    m_state[15] = oldState[11];
}

void AES::invShiftRows()
{
    std::array<uint8_t, 16> oldState = m_state;
    
    // Row 1 (indices 0, 4, 8, 12) doesn't shift

    // Row 2 (indices 1, 5, 9, 13) shifts 1
    m_state[1] = oldState[13];
    m_state[5] = oldState[1];
    m_state[9] = oldState[5];
    m_state[13] = oldState[9];

    // Row 3 (indices 2, 6, 10, 14) shifts 2
    m_state[2] = oldState[10];
    m_state[6] = oldState[14];
    m_state[10] = oldState[2];
    m_state[14] = oldState[6];

    // Row 4 (indices 3, 7, 11, 15) shifts 3
    m_state[3] = oldState[7];
    m_state[7] = oldState[11];
    m_state[11] = oldState[15];
    m_state[15] = oldState[3];
}

void AES::mixColumns()
{
    std::array<uint8_t, 16> oldState = m_state;
    for (int i = 0; i < 16; i += 4)
    {
        m_state[i]  = GMUL2[oldState[i]] ^ GMUL3[oldState[i+1]] ^ oldState[i+2]        ^ oldState[i+3];
        m_state[i+1]= oldState[i]        ^ GMUL2[oldState[i+1]] ^ GMUL3[oldState[i+2]] ^ oldState[i+3];
        m_state[i+2]= oldState[i]        ^ oldState[i+1]        ^ GMUL2[oldState[i+2]] ^ GMUL3[oldState[i+3]];
        m_state[i+3]= GMUL3[oldState[i]] ^ oldState[i+1]        ^ oldState[i+2]        ^ GMUL2[oldState[i+3]];
    }
}

void AES::invMixColumns()
{
    std::array<uint8_t, 16> oldState = m_state;
    for (int i = 0; i < 16; i += 4)
    {
        m_state[i]  = GMUL14[oldState[i]] ^ GMUL11[oldState[i+1]] ^ GMUL13[oldState[i+2]] ^ GMUL9[oldState[i+3]];
        m_state[i+1]= GMUL9[oldState[i]]  ^ GMUL14[oldState[i+1]] ^ GMUL11[oldState[i+2]] ^ GMUL13[oldState[i+3]];
        m_state[i+2]= GMUL13[oldState[i]] ^ GMUL9[oldState[i+1]]  ^ GMUL14[oldState[i+2]] ^ GMUL11[oldState[i+3]];
        m_state[i+3]= GMUL11[oldState[i]] ^ GMUL13[oldState[i+1]] ^ GMUL9[oldState[i+2]]  ^ GMUL14[oldState[i+3]];
    }
}
